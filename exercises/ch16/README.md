## Exercises 16.1
- When the compiler instantiates a template, it uses the actual template parameters instead of the corresponding template parameters to create a new "instance" of the template.

## Exercises 16.2
## Exercises 16.3
## Exercises 16.4
## Exercises 16.5
## Exercises 16.6
## Exercises 16.7
- because some class may not have `operator<`

## Exercises 16.8

## Exercises 16.9
- A function template is a formula that can be used to generate a function version for a specific type. The class template is used to generate the blueprint of the class. The difference from the function template is that the compiler cannot infer the template parameter types for the class template. If we have seen it many times, in order to use a class template, we must provide additional information in angle brackets after the template name.

## Exercises 16.10
- the complier will rewrite the template, change the `T` to the real type 

## Exercises 16.11
## Exercises 16.12
## Exercises 16.13
- 1 <=> 1
## Exercises 16.14
## Exercises 16.15
## Exercises 16.16

## Exercises 16.17
- When using template members, because the compiler does not have the definition of the template, when the members used are types, typename should be used to remind the compiler

## Exercises 16.17
```c++
// a
template <typename T, U, typename V> void f1(T, U, V);  // error
template <typename T, typename U, typename V> void f1(T, U, V);

// b 
template <typename T> T f2(int &T); // error
template <typename T> T f2(int &i); 

// c
inline template <typename T> T foo(T, unsigned int *);  // error
template <typename T> inline T foo(T, unsigned int *);

// d 
template <typename T> f4(T, T); // error
template <typename T> T f4(T, T);

// f
typedef char Ctype;
template <typename Ctype> Ctype f5(Ctype a)
```

## Exercises 16.18
## Exercises 16.19
## Exercises 16.20
## Exercises 16.21
## Exercises 16.22
## Exercises 16.23
- just one delete because .... 

## Execises 16.24
- Declare the string version of the template class
- Fully instantiate the Sales_data version of the template class

## Execises 16.25
## Execises 16.26
## Execises 16.27
## Execises 16.28
## Execises 16.29
## Execises 16.30
## Execises 16.31
## Execises 16.32
- The compiler uses the call arguments to find the template arguments. The functions generated by these template arguments are the closest match to the call, and will perform const/array/function conversion

## Exercises 16.33
1. const
2. array to pointer, function to pointer. 

## Exercises 16.34
```c++
template <class T> int compare(const T &t, const T &t);
// a
compare("hi", "world"); // error - compare(const char (&)[3], const char (&)[6])
// b
compare("bye", "dad");  // compare(const char (&)[4], const char (&)[4])
```

## Exercises 16.35
```c++
template <typename T> T calc(T, int);
template <typename T> T fcn(T, T);
double d; float f; char c;
// a
calc(c, 'c');   // template <char> char calc(c, 'c')
// b
calc(d, f);     // template <double> double calc(d, f)
// c
fcn(c, 'c')     // template <char> char fcn(c, 'c')
// d
fnc(d, f)       // error
```

## Exercises 16.36
```c++
template <typename T> void f1(T, T);
template <typename T1, typename T2> void f2(T1, T2);
int i = 0, j = 42, *p1 = &i, *p2 = &j;
const int *cp1 = &i, *cp2 = &j;
// a
f1(p1, p2);     // T -> int *
// b
f2(p1, p2)      // T1 -> int *, T2 -> int *
// c 
f1(cp1, cp2)    // T -> const int *
// d
f2(cp1, cp2)    // T1 -> const int *, T2 -> const int *
// e
// f1(p1, cp1)     // T -> const int * error
// f
f2(p1, cp1)     // T1 -> int *, T2 -> const int *
```

## Exercises 16.37
## Exercises 16.38
- it is the return type

## Exercises 16.39
## Exercises 16.40
## Exercises 16.41
## Exercises 16.42
```c++
template <typename T> void g(T &&val);
int i = 0; const int ci = i;
// a - T is (int &)
g(i);   
// b - T is (const int &)
g(ci);  
// c - T is (int)
g(i * ci);
```


## Exercises 16.43
- int &

## Exercises 16.44
- T: int, int, int
- const T &: int, int, int

## Exercises 16.45

## Exercises 16.46
- Move objects in the old space to the new space, and the objects in the old space become destructible

## Exercises 16.47
## Exercises 16.48
## Exercises 16.49
```c++
template <typename T> void f(T);
template <typename T> void f(const T *);
template <typename T> void g(T);
template <typename T> void g(T *);
int i = 42, *p = &i;
const int ci = 0, *p2 = &ci;
g(42);
f(42);
// g(T) -> g(int *), T -> int *, int * -> int *
// g(T *) -> g(int *), T -> int, int * -> int *
g(p);
// f(T) -> f(int *), T -> int *, int * -> int *
// f(const T *) -> f(const int *), T -> int, int * -> const int *
f(p);
g(ci);
f(ci);
// g(T) -> g(const int *), T -> const int *, const int * -> const int *
// g(T *) -> g(const int *), T -> const int, const int * -> const int *
g(p2);
// f(T) -> f(const int *), T -> const int *, const int * -> const int *
// f(const T *) -> f(const int *), T -> int, const int * -> const int * 
f(p2);
/*
template <typename T> void g(T);
template <typename T> void f(T);
template <typename T> void g(T *);
template <typename T> void f(T);
template <typename T> void g(T);
template <typename T> void f(T);
template <typename T> void g(T *);
template <typename T> void f(const T *);
*/
```